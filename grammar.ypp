/********************************************************
 * 
 ********************************************************/
%{
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>
#include <list>
	
#include "InstructionTree.h"

//-- Lexer prototype required by bison, aka getNextToken()
extern FILE *yyin;
int yylex(); 
int yyerror(const char *p) { printf("Parse error!, \"%s\"\n", p); return 0; }

std::list<Base *> s_statements, s_statementsRescheduled;

#define AT 27

%}

%union {
  Base *p; 
};
%token <p> NUM
%token <p> OPA OPM LP RP SEMICOLON COMMA
%type  <p>  res
%type <p> left right signal addaluop mulaluop adddestreg addrega addregb muldestreg mulrega mulregb ra_reg rb_reg acc_reg smallimm addsecondarg mulsecondarg setflags instcond optinstcond il brcond optabsolute valueorlabel vecrot

%token <p> ADDNOP FADD FSUB FMIN FMAX FMINABS FMAXABS FTOI ITOF ADD SUB SHR ASR ROR SHL MIN MAX AND OR XOR NOT CLZ ADDV8ADDS ADDV8SUBSS
%token <p> MULNOP FMUL MUL24 V8MULD V8MIN V8MAX MULV8ADDS MULV8SUBS
%token <p> IL BR
%token <p> SEM INC DEC

%token <p> NEVER AL ZS ZC NS NC CS CC
%token <p> ALLZS ALLZC ANYZS ANYZC ALLNS ALLNC ANYNS ANYNC ALLCS ALLCC ANYCS ANYCC

%token <p> SETFLAGS ABSOLUTE VECROT
%token <p> BREAKPOINT NOSIGNAL THREADSWITCH PROGRAMEND SCOREBOARDWAIT SCOREBOARDUNLOCK LASTHREADSWITCH COVERAGELOAD COLOURLOAD COLOURLOADPE LOADTMU0 LOADTMU1 ALPHAMASKLOAD SMALLIMMORVECROT LOADIMM BRANCH
%token <p> RA_REG RB_REG ACC_REG
%token <p> LABEL_DEF LABEL_TARGET
%token <p> WORD SHORT BYTE

%token <p> NOP MOV
%token <p> LOAD_WORD STORE_WORD LEA
%token <p> REORDER_BEGIN REORDER_END

%token <p> UNIFRA UNIFRB
%token <p> NOPRA NOPRB NOPWA NOPWB
%token <p> VPMRA VPMRB VPMWA VPMWB
%token <p> ACC0WA ACC0WB ACC1WA ACC1WB ACC2WA ACC2WB ACC3WA ACC3WB ACC5WA ACC5WB
%token <p> VPMRABUSY VPMRBBUSY
%token <p> VPMWASETUP VPMWBSETUP
%token <p> VPMRAWAIT VPMRBWAIT
%token <p> VPMWAADDR VPMWBADDR
%token <p> ELEMRA QPURB

//-- GRAMMAR RULES ---------------------------------------
%%

run: res run
		{
		}
	| res
		{
		}

res: NOP
		{
			AddPipeInstruction *pLeft = new AddPipeInstruction(*new Opcode(kAddNop),
					*new Register(Register::kAcc, 0),
					*new Register(Register::kAcc, 0),
					*new Register(Register::kAcc, 0),
					*new InstructionCondition(kNever),
					false);
			
			$$ = new AluInstruction(*pLeft,
					BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
					AluSignal::DefaultSignal());
			s_statements.push_back($$);
		}
	| MOV setflags optinstcond adddestreg COMMA addrega
	{
		//need more versions with different args
		Value *pFlags = dynamic_cast<Value *>$2;
		InstructionCondition *pCc = dynamic_cast<InstructionCondition *>$3;
		Register *pDest = dynamic_cast<Register *>$4;
		Register *pSource = dynamic_cast<Register *>$6;
		
		assert(pFlags);
		assert(pCc);
		assert(pDest);
		assert(pSource);
		assert(pFlags->GetIntValue() == 1 || pFlags->GetIntValue() == 0);
		
		AddPipeInstruction *pLeft = new AddPipeInstruction(*new Opcode(kOr),
					*pDest,
					*pSource,
					*pSource,
					*pCc,
					pFlags->GetIntValue() ? true : false);
			
			$$ = new AluInstruction(*pLeft,
					BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
					AluSignal::DefaultSignal());
			s_statements.push_back($$);
		
		delete pFlags;
	}
	| LOAD_WORD adddestreg COMMA addrega COMMA valueorlabel
		{
			Register *pDest = dynamic_cast<Register *>$2;
			Register *pSource = dynamic_cast<Register *>$4;
			Value *pImm = dynamic_cast<Value *>$6;
			
			assert(pDest);
			assert(pSource);
			assert(pImm);
			
			bool isLabel = dynamic_cast<Label *>$6 ? true : false;
			
			//create a barrier
			s_statements.push_back(
					new ReorderControl(false)
			);
			s_statements.push_back(
					new ReorderControl(true)
			);
			
			//configure dma read
			{
				s_statements.push_back(
					new IlInstruction(*new Register(Register::kRa, 49),			//write to vpm_vcd_rd_setup
						*new Value((1 << 31)			//vdr dma basic setup
								| (0 << 28)				//width=32-bit
								| (1 << 24)				//row-to-row pitch in memory is 8*2^xxx
								| (16 << 20)			//16 elements to a row
								| (1 << 16)				//one row
								| (0 << 12)				//row-to-row pitch in vpm (only loading one row anyway)
								| (0 << 11)				//horizontal
								| (0 << 0)),			//X=0, Y=0,
						*new InstructionCondition(kAlways),
						false)
				);
			}
		
			//write load address and trigger load
			if (!isLabel && pImm->GetIntValue() >= -16 && pImm->GetIntValue() <= 15)
			{
				Register *p = pSource;
				
				//we can't do dest = rb OP imm, only ra OP imm so go via AT-A
				if (pSource->GetLocation() == Register::kRb)
				{
					Register *pAt = new Register(Register::kRa, AT);
					
					AddPipeInstruction *pLeft = new AddPipeInstruction(*new Opcode(kOr),
							*pAt,
							*pSource,
							*pSource,
							*new InstructionCondition(kAlways),
							false);
					
					$$ = new AluInstruction(*pLeft,
							BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
							AluSignal::DefaultSignal());
					s_statements.push_back($$);
					
					p = pAt;
				}
				
				AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kAdd),
						*new Register(Register::kRa, 50), *p, *new SmallImm(*pImm, false),				//vpm_ld_addr = pSource + imm
						*new InstructionCondition(kAlways), false);
				s_statements.push_back(
						new AluInstruction(rLeft,
								BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
								AluSignal::DefaultSignal())
				);
			}
			else
			{
				Register *p = pSource;
				
				//go via AT-A if source is in rb
				if (pSource->GetLocation() == Register::kRb)
				{
					Register *pAtA = new Register(Register::kRa, AT);
					
					AddPipeInstruction *pLeft = new AddPipeInstruction(*new Opcode(kOr),
							*pAtA,
							*pSource,
							*pSource,
							*new InstructionCondition(kAlways),
							false);
					
					$$ = new AluInstruction(*pLeft,
							BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
							AluSignal::DefaultSignal());
					s_statements.push_back($$);
					
					p = pAtA;
				}
				
				Register *pAtB = new Register(Register::kRb, AT);
				s_statements.push_back(
					new IlInstruction(*pAtB,			//write to AT
						*pImm,
						*new InstructionCondition(kAlways),
						false)
				);
				AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kAdd),
						*new Register(Register::kRa, 50), *p, *pAtB,				//vpm_ld_addr = pSource + AT
						*new InstructionCondition(kAlways), false);
				s_statements.push_back(
						new AluInstruction(rLeft,
								BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
								AluSignal::DefaultSignal())
				);
			}
		
			//wait for the dma to complete
			{
				AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kOr),
						*new Register(Register::kRa, 39), *new Register(Register::kRa, 50), *new Register(Register::kRa, 50), //wra_nop = vpm_ld_wait | vpm_ld_wait
						*new InstructionCondition(kAlways), false);
				s_statements.push_back(
						new AluInstruction(rLeft,
								BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
								AluSignal::DefaultSignal())
				);
			}
			
			//create a barrier
			s_statements.push_back(
					new ReorderControl(false)
			);
			s_statements.push_back(
					new ReorderControl(true)
			);
		
			//trigger the load from vpm to qpu
			{
				s_statements.push_back(
					new IlInstruction(*new Register(Register::kRa, 49),			//write to vpm_vcd_rd_setup
						*new Value((0 << 30)			//vpm generic block read setup
								| (1 << 20)				//one vector to read
								| (0 << 12)				//stride, only reading one vector anyway
								| (1 << 11)				//horizontal
								| (2 << 8)				//32-bit
								| (0 << 0)),			//X=0, Y=0
						*new InstructionCondition(kAlways),
						false)
				);
			}
		
			//move from vpm read dat to dest
			//wait for the dma to complete
			{
				//need to broadcast loads to lr
				if (pDest->GetLocation() == Register::kRa && pDest->GetId() == 31)
				{
					Register *pAcc5 = new Register(Register::kAcc, 5);
					
					MulPipeInstruction &rRight = *new MulPipeInstruction(*new Opcode(kV8min),
							*pAcc5, *new Register(Register::kRa, 48), *new Register(Register::kRa, 48), //acc5 = rda_vpm_dat | rda_vpm_dat
							0,
							*new InstructionCondition(kAlways), false);
					
					s_statements.push_back(
							new AluInstruction(BasePipeInstruction::GenerateCompatibleInstruction(rRight),
									rRight,
									AluSignal::DefaultSignal())
					);
					
					AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kOr),
							*pDest, *pAcc5, *pAcc5, 													//lr = acc5 | accc5
							*new InstructionCondition(kAlways), false);
					
					s_statements.push_back(
							new AluInstruction(rLeft,
									BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
									AluSignal::DefaultSignal())
					);
				}
				else
				{
					AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kOr),
							*pDest, *new Register(Register::kRa, 48), *new Register(Register::kRa, 48), //dest = rda_vpm_dat | rda_vpm_dat
							*new InstructionCondition(kAlways), false);
					
					s_statements.push_back(
							new AluInstruction(rLeft,
									BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
									AluSignal::DefaultSignal())
					);
				}
			}
			
			//create a barrier (to prevent something getting written into pDest)
		/*	s_statements.push_back(
					new ReorderControl(false)
			);
			s_statements.push_back(
					new ReorderControl(true)
			);*/
		}
	| STORE_WORD addrega COMMA addrega COMMA NUM COMMA valueorlabel
		{
			Register *pToStore = dynamic_cast<Register *>$2;
			Register *pSource = dynamic_cast<Register *>$4;
			Value *pImm = dynamic_cast<Value *>$6;
			Value *pWordCount = dynamic_cast<Value *>$8;
			
			assert(pToStore);
			assert(pSource);
			assert(pImm);
			assert(pWordCount);
			assert(pWordCount->GetIntValue() >= 1 && pWordCount->GetIntValue() <= 16);
			
			bool isLabel = dynamic_cast<Label *>$6 ? true : false;
			
			//create a barrier
			s_statements.push_back(
					new ReorderControl(false)
			);
			s_statements.push_back(
					new ReorderControl(true)
			);
			
			//trigger the store from qpu to vpm
			{
				s_statements.push_back(
					new IlInstruction(*new Register(Register::kRb, 49),			//write to vpm_vcd_wr_setup
						*new Value((0 << 30)			//vpm generic block write setup
								| (0 << 12)				//stride, only reading one vector anyway
								| (1 << 11)				//horizontal
								| (2 << 8)				//32-bit
								| (0 << 0)),			//X=0, Y=0
						*new InstructionCondition(kAlways),
						false)
				);
			}
		
			//move from vpm read dat to dest
			//wait for the dma to complete
			{
				AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kOr),
						*new Register(Register::kRa, 48), *pToStore, *pToStore,					//wra_vpm_dat = to store | to store
						*new InstructionCondition(kAlways), false);
				s_statements.push_back(
						new AluInstruction(rLeft,
								BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
								AluSignal::DefaultSignal())
				);
			}
			
			//create a barrier
			s_statements.push_back(
					new ReorderControl(false)
			);
			s_statements.push_back(
					new ReorderControl(true)
			);
			
			
			//configure dma write
			{
				s_statements.push_back(
					new IlInstruction(*new Register(Register::kRb, 49),			//write to vpm_vcd_wd_setup
						*new Value((2 << 30)			//vdw dma basic setup
								| (1 << 23)				//one row
								| (pWordCount->GetIntValue() << 16)			//row length of 2d block in memory
								| (1 << 14)				//horizontal
								| (0 << 3)				//X=0, Y=0,
								| (0 << 0)),			//32-bit
						*new InstructionCondition(kAlways),
						false)
				);
			}
		
			//write store address and trigger load
			if (!isLabel && pImm->GetIntValue() >= -16 && pImm->GetIntValue() <= 15)
			{
				Register *p = pSource;
				//go via AT-A if source is in rb
				if (pSource->GetLocation() == Register::kRb)
				{
					Register *pAtA = new Register(Register::kRa, AT);
					
					AddPipeInstruction *pLeft = new AddPipeInstruction(*new Opcode(kOr),
							*pAtA,
							*pSource,
							*pSource,
							*new InstructionCondition(kAlways),
							false);
					
					$$ = new AluInstruction(*pLeft,
							BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
							AluSignal::DefaultSignal());
					s_statements.push_back($$);
					
					p = pAtA;
				}
				
				AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kAdd),
						*new Register(Register::kRb, 50), *p, *new SmallImm(*pImm, false),				//vpm_st_addr = pSource + imm
						*new InstructionCondition(kAlways), false);
				s_statements.push_back(
						new AluInstruction(rLeft,
								BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
								AluSignal::DefaultSignal())
				);
			}
			else
			{
				Register *p = pSource;
				//go via AT-A if source is in rb
				if (pSource->GetLocation() == Register::kRb)
				{
					Register *pAtA = new Register(Register::kRa, AT);
					
					AddPipeInstruction *pLeft = new AddPipeInstruction(*new Opcode(kOr),
							*pAtA,
							*pSource,
							*pSource,
							*new InstructionCondition(kAlways),
							false);
					
					$$ = new AluInstruction(*pLeft,
							BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
							AluSignal::DefaultSignal());
					s_statements.push_back($$);
					
					p = pAtA;
				}
				
				Register *pAtB = new Register(Register::kRb, AT);
				s_statements.push_back(
					new IlInstruction(*pAtB,			//write to AT
						*pImm,
						*new InstructionCondition(kAlways),
						false)
				);
				AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kAdd),
						*new Register(Register::kRb, 50), *p, *pAtB,				//vpm_st_addr = pSource + AT
						*new InstructionCondition(kAlways), false);
				s_statements.push_back(
						new AluInstruction(rLeft,
								BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
								AluSignal::DefaultSignal())
				);
			}
		
			//wait for the dma to complete
			{
				AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kOr),
						*new Register(Register::kRa, 39), *new Register(Register::kRb, 50), *new Register(Register::kRb, 50), //wra_nop = vpm_st_wait | vpm_st_wait
						*new InstructionCondition(kAlways), false);
				s_statements.push_back(
						new AluInstruction(rLeft,
								BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
								AluSignal::DefaultSignal())
				);
			}
			
			//create a barrier (currently to prevent other registers stealing pSource)
			/*s_statements.push_back(
					new ReorderControl(false)
			);
			s_statements.push_back(
					new ReorderControl(true)
			);*/
		}
	| LEA addrega COMMA addrega COMMA valueorlabel
		{
			Register *pDest = dynamic_cast<Register *>$2;
			Register *pSource = dynamic_cast<Register *>$4;
			Value *pImm = dynamic_cast<Value *>$6;
			
			assert(pDest);
			assert(pSource);
			assert(pImm);
			
			bool isLabel = dynamic_cast<Label *>$6 ? true : false;
			
			if (!isLabel && pImm->GetIntValue() >= -16 && pImm->GetIntValue() <= 15)
			{
				AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kAdd),
						*pDest, *pSource, *new SmallImm(*pImm, false),				//pDest = pSource + imm
						*new InstructionCondition(kAlways), false);
				s_statements.push_back(
						new AluInstruction(rLeft,
								BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
								AluSignal::DefaultSignal())
				);
			}
			else
			{
				Register *pAt = new Register(Register::kRb, AT);
				s_statements.push_back(
					new IlInstruction(*pAt,			//write to AT
						*pImm,
						*new InstructionCondition(kAlways),
						false)
				);
				AddPipeInstruction &rLeft = *new AddPipeInstruction(*new Opcode(kAdd),
						*pDest, *pSource, *pAt,				//pDest = pSource + AT
						*new InstructionCondition(kAlways), false);
				s_statements.push_back(
						new AluInstruction(rLeft,
								BasePipeInstruction::GenerateCompatibleInstruction(rLeft),
								AluSignal::DefaultSignal())
				);
			}
		}
	| REORDER_BEGIN
		{
			s_statements.push_back(new ReorderControl(true));
		}
	| REORDER_END
		{
			s_statements.push_back(new ReorderControl(false));
		}
	| signal
		{
			AluSignal *pSig = dynamic_cast<AluSignal *>$1;
			assert(pSig);
			
			AddPipeInstruction *pLeft = new AddPipeInstruction(*new Opcode(kAddNop),
					*new Register(Register::kAcc, 0),
					*new Register(Register::kAcc, 0),
					*new Register(Register::kAcc, 0),
					*new InstructionCondition(kAlways),
					false);
			
			$$ = new AluInstruction(*pLeft,
					BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
					*pSig);
			s_statements.push_back($$);
		}
	| left
		{
			AddPipeInstruction *pLeft = dynamic_cast<AddPipeInstruction *>$1;
			assert(pLeft);
			$$ = new AluInstruction(*pLeft,
					BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
					AluSignal::DefaultSignal());
			s_statements.push_back($$);
		}
	| right
		{
			MulPipeInstruction *pRight = dynamic_cast<MulPipeInstruction *>$1;
			assert(pRight);
			$$ = new AluInstruction(BasePipeInstruction::GenerateCompatibleInstruction(*pRight),
					*pRight,
					AluSignal::DefaultSignal());
			s_statements.push_back($$);
		}
	| left SEMICOLON right
		{
			AddPipeInstruction *pLeft = dynamic_cast<AddPipeInstruction *>$1;
			MulPipeInstruction *pRight = dynamic_cast<MulPipeInstruction *>$3;
			assert(pLeft);
			assert(pRight);
			
			AluSignal &rSig = AluSignal::DefaultSignal();
			
			if (BasePipeInstruction::AreCompatible(*pLeft, *pRight, rSig))
				s_statements.push_back(new AluInstruction(*pLeft, *pRight, rSig));
			else
			{
				printf("instructions not compatible for dual-issue; being split into two\n");
				s_statements.push_back(new AluInstruction(*pLeft,
						BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
						rSig));
				
				s_statements.push_back(new AluInstruction(BasePipeInstruction::GenerateCompatibleInstruction(*pRight),
						*pRight,
						rSig));
			}
		}
	| left SEMICOLON signal
		{
			AddPipeInstruction *pLeft = dynamic_cast<AddPipeInstruction *>$1;
			AluSignal *pSig = dynamic_cast<AluSignal *>$3;
			
			assert(pLeft);
			assert(pSig);
			
			MulPipeInstruction &rRight = BasePipeInstruction::GenerateCompatibleInstruction(*pLeft);
			
			assert(BasePipeInstruction::AreCompatible(*pLeft, rRight, *pSig));
			
			s_statements.push_back(new AluInstruction(*pLeft, rRight, *pSig));
		}
	| right SEMICOLON signal
		{
			MulPipeInstruction *pRight = dynamic_cast<MulPipeInstruction *>$1;
			AluSignal *pSig = dynamic_cast<AluSignal *>$3;
			
			assert(pRight);
			assert(pSig);
			
			$$ = new AluInstruction(BasePipeInstruction::GenerateCompatibleInstruction(*pRight),
					*pRight, *pSig);
			s_statements.push_back($$);
		}
	| left SEMICOLON right SEMICOLON signal
		{
			AddPipeInstruction *pLeft = dynamic_cast<AddPipeInstruction *>$1;
			MulPipeInstruction *pRight = dynamic_cast<MulPipeInstruction *>$3;
			AluSignal *pSig = dynamic_cast<AluSignal *>$5;
			
			assert(pLeft);
			assert(pRight);
			assert(pSig);
			
			if (BasePipeInstruction::AreCompatible(*pLeft, *pRight, *pSig))
				s_statements.push_back(new AluInstruction(*pLeft, *pRight, *pSig));
			else
			{
				printf("instructions not compatible for dual-issue; being split into two\n");
				s_statements.push_back(new AluInstruction(*pLeft,
						BasePipeInstruction::GenerateCompatibleInstruction(*pLeft),
						*pSig));
				
				s_statements.push_back(new AluInstruction(BasePipeInstruction::GenerateCompatibleInstruction(*pRight),
						*pRight,
						*pSig));
			}
		}
| il
		{
			IlInstruction *p = dynamic_cast<IlInstruction *>$1;
			assert(p);
			s_statements.push_back(p);
		}
| il SEMICOLON il
		{
			IlInstruction *p1 = dynamic_cast<IlInstruction *>$1;
			IlInstruction *p2 = dynamic_cast<IlInstruction *>$3;
			
			assert(p1);
			assert(p2);
			
			s_statements.push_back(p1);
			s_statements.push_back(p2);
		}
| SEM NUM COMMA INC
		{
			Value *p = dynamic_cast<Value *>$2;
			SemInstruction *s = new SemInstruction(*p, SemInstruction::kInc);
			s_statements.push_back(s);
		}
| SEM NUM COMMA DEC
		{
			Value *p = dynamic_cast<Value *>$2;
			SemInstruction *s = new SemInstruction(*p, SemInstruction::kDec);
			s_statements.push_back(s);
		}
| BR optabsolute brcond adddestreg COMMA muldestreg COMMA ra_reg
		{
			Value *pAbs = dynamic_cast<Value *>$2;
			BrCondition *pCond = dynamic_cast<BrCondition *>$3;
			Register *pDestA = dynamic_cast<Register *>$4;
			Register *pDestM = dynamic_cast<Register *>$6;
			Register *pSource = dynamic_cast<Register *>$8;
			
			assert(pAbs);
			assert(pCond);
			assert(pDestA);
			assert(pDestM);
			assert(pSource);
			
			assert(pAbs->GetIntValue() == 1 || pAbs->GetIntValue() == 0);
			BranchInstruction *b = new BranchInstruction(pAbs->GetIntValue() ? true : false,
					*pCond, *pDestA, *pDestM, *pSource,
					*new Value(0));
			s_statements.push_back(b);
			
			delete pAbs;
		}
| BR optabsolute brcond adddestreg COMMA muldestreg COMMA ra_reg COMMA NUM
		{
			Value *pAbs = dynamic_cast<Value *>$2;
			BrCondition *pCond = dynamic_cast<BrCondition *>$3;
			Register *pDestA = dynamic_cast<Register *>$4;
			Register *pDestM = dynamic_cast<Register *>$6;
			Register *pSource = dynamic_cast<Register *>$8;
			Value *pImm = dynamic_cast<Value *>$10;
			
			assert(pAbs);
			assert(pCond);
			assert(pDestA);
			assert(pDestM);
			assert(pSource);
			assert(pImm);
			
			assert(pAbs->GetIntValue() == 1 || pAbs->GetIntValue() == 0);
			BranchInstruction *b = new BranchInstruction(pAbs->GetIntValue() ? true : false,
					*pCond, *pDestA, *pDestM, *pSource, *pImm);
			s_statements.push_back(b);
			
			delete pAbs;
		}
| BR optabsolute brcond adddestreg COMMA muldestreg COMMA valueorlabel
		{
			Value *pAbs = dynamic_cast<Value *>$2;
			BrCondition *pCond = dynamic_cast<BrCondition *>$3;
			Register *pDestA = dynamic_cast<Register *>$4;
			Register *pDestM = dynamic_cast<Register *>$6;
			Value *pImm = dynamic_cast<Value *>$8;
			
			assert(pAbs);
			assert(pCond);
			assert(pDestA);
			assert(pDestM);
			assert(pImm);
			
			assert(pAbs->GetIntValue() == 1 || pAbs->GetIntValue() == 0);
			BranchInstruction *b = new BranchInstruction(pAbs->GetIntValue() ? true : false,
					*pCond, *pDestA, *pDestM, *pImm);
			s_statements.push_back(b);
			
			delete pAbs;
		}
| LABEL_DEF
		{
			Label *pLabel = dynamic_cast<Label *>$1;
			assert(pLabel);
			s_statements.push_back(pLabel);
		}
| WORD NUM
		{
			Value *pValue = dynamic_cast<Value *>$2;
			assert(pValue);
			pValue->SetSize(4);
			s_statements.push_back(pValue);
		}
| SHORT NUM
		{
			Value *pValue = dynamic_cast<Value *>$2;
			assert(pValue);
			pValue->SetSize(2);
			s_statements.push_back(pValue);
		}
| BYTE NUM
		{
			Value *pValue = dynamic_cast<Value *>$2;
			assert(pValue);
			pValue->SetSize(1);
			s_statements.push_back(pValue);
		}

valueorlabel: NUM | LABEL_TARGET

signal: BREAKPOINT | NOSIGNAL | THREADSWITCH | PROGRAMEND | SCOREBOARDWAIT | SCOREBOARDUNLOCK | LASTHREADSWITCH | COVERAGELOAD | COLOURLOAD | COLOURLOADPE | LOADTMU0 | LOADTMU1 | ALPHAMASKLOAD | SMALLIMMORVECROT | LOADIMM | BRANCH

addaluop: ADDNOP | FADD | FSUB | FMIN | FMAX | FMINABS | FMAXABS | FTOI | ITOF | ADD | SUB | SHR | ASR | ROR | SHL | MIN | MAX | AND | OR | XOR | NOT | CLZ | ADDV8ADDS | ADDV8SUBSS

mulaluop: MULNOP | FMUL | MUL24 | V8MULD | V8MIN | V8MAX | MULV8ADDS | MULV8SUBS

left: addaluop setflags optinstcond adddestreg COMMA addrega COMMA addsecondarg
	{
		Opcode *pOp = dynamic_cast<Opcode *>$1;
		Value *pFlags = dynamic_cast<Value *>$2;
		InstructionCondition *pCc = dynamic_cast<InstructionCondition *>$3;
		Register *pDest = dynamic_cast<Register *>$4;
		Register *pSource1 = dynamic_cast<Register *>$6;
		SecondSource *pSource2 = dynamic_cast<SecondSource *>$8;
		
		assert(pOp);
		assert(pFlags);
		assert(pCc);
		assert(pDest);
		assert(pSource1);
		assert(pSource2);
		assert(pFlags->GetIntValue() == 1 || pFlags->GetIntValue() == 0);
		
		$$ = new AddPipeInstruction(*pOp, *pDest, *pSource1, *pSource2,
				*pCc,
				pFlags->GetIntValue() ? true : false);
		
		delete pFlags;
	}

right: mulaluop setflags optinstcond muldestreg vecrot COMMA mulrega COMMA mulsecondarg
	{
		Opcode *pOp = dynamic_cast<Opcode *>$1;
		Value *pFlags = dynamic_cast<Value *>$2;
		InstructionCondition *pCc = dynamic_cast<InstructionCondition *>$3;
		Register *pDest = dynamic_cast<Register *>$4;
		SmallImm *pVecrot = dynamic_cast<SmallImm *>$5;
		Register *pSource1 = dynamic_cast<Register *>$7;
		SecondSource *pSource2 = dynamic_cast<SecondSource *>$9;
		
		assert(pOp);
		assert(pFlags);
		assert(pCc);
		assert(pDest);
		if ($5)
			assert(pVecrot);
		assert(pSource1);
		assert(pSource2);
		assert(pFlags->GetIntValue() == 1 || pFlags->GetIntValue() == 0);
		
		$$ = new MulPipeInstruction(*pOp, *pDest, *pSource1, *pSource2,
				pVecrot, *pCc,
				pFlags->GetIntValue() ? true : false);
		
		delete pFlags;
	}

il: IL setflags optinstcond adddestreg COMMA valueorlabel
	{
		Value *pFlags = dynamic_cast<Value *>$2;
		InstructionCondition *pCc = dynamic_cast<InstructionCondition *>$3;
		Register *pDest = dynamic_cast<Register *>$4;
		Value *pImm = dynamic_cast<Value *>$6;
		
		assert(pFlags);
		assert(pCc);
		assert(pDest);
		assert(pImm);
		assert(pFlags->GetIntValue() == 1 || pFlags->GetIntValue() == 0);
		
		$$ = new IlInstruction(*pDest, *pImm, *pCc,
				pFlags->GetIntValue() ? true : false);
		
		delete pFlags;
	}

il: IL setflags optinstcond muldestreg COMMA valueorlabel
	{
		Value *pFlags = dynamic_cast<Value *>$2;
		InstructionCondition *pCc = dynamic_cast<InstructionCondition *>$3;
		Register *pDest = dynamic_cast<Register *>$4;
		Value *pImm = dynamic_cast<Value *>$6;
		
		assert(pFlags);
		assert(pCc);
		assert(pDest);
		assert(pImm);
		assert(pFlags->GetIntValue() == 1 || pFlags->GetIntValue() == 0);
		
		$$ = new IlInstruction(*pDest, *pImm, *pCc,
				pFlags->GetIntValue() ? true : false);
		
		delete pFlags;
	}

addsecondarg: addregb
| smallimm
	{
		Value *pImm = dynamic_cast<Value *>$1;
		assert(pImm);
		$$ = new SmallImm(*pImm, false);
	}

mulsecondarg: mulregb
| smallimm
	{
		Value *pImm = dynamic_cast<Value *>$1;
		assert(pImm);
		$$ = new SmallImm(*pImm, false);
	}

vecrot: VECROT NUM
		{
			Value *pImm = dynamic_cast<Value *>$2;
			assert(pImm);
			$$ = new SmallImm(*pImm, true);
		}
		| { $$ = 0; }

adddestreg: ra_reg | rb_reg | acc_reg | NOPWA | NOPWB | VPMWA | VPMWB | VPMWASETUP | VPMWBSETUP | VPMWAADDR | VPMWBADDR | ACC0WA | ACC0WB | ACC1WA | ACC1WB | ACC2WA | ACC2WB | ACC3WA | ACC3WB | ACC5WA | ACC5WB

muldestreg: ra_reg | rb_reg | acc_reg | NOPWA | NOPWB | VPMWA | VPMWB | VPMWASETUP | VPMWBSETUP | VPMWAADDR | VPMWBADDR | ACC0WA | ACC0WB | ACC1WA | ACC1WB | ACC2WA | ACC2WB | ACC3WA | ACC3WB | ACC5WA | ACC5WB

addrega: ra_reg | rb_reg | acc_reg | NOPRA | NOPRB | UNIFRA | UNIFRB | ELEMRA | QPURB | VPMRA | VPMRB | VPMRABUSY | VPMRBBUSY | VPMRAWAIT | VPMRBWAIT

addregb: ra_reg | rb_reg | acc_reg | NOPRA | NOPRB | UNIFRA | UNIFRB | ELEMRA | QPURB | VPMRA | VPMRB | VPMRABUSY | VPMRBBUSY | VPMRAWAIT | VPMRBWAIT

mulrega: ra_reg | rb_reg | acc_reg | NOPRA | NOPRB | UNIFRA | UNIFRB | ELEMRA | QPURB | VPMRA | VPMRB | VPMRABUSY | VPMRBBUSY | VPMRAWAIT | VPMRBWAIT

mulregb: ra_reg | rb_reg | acc_reg | NOPRA | NOPRB | UNIFRA | UNIFRB | ELEMRA | QPURB | VPMRA | VPMRB | VPMRABUSY | VPMRBBUSY | VPMRAWAIT | VPMRBWAIT

acc_reg: ACC_REG

ra_reg: RA_REG

rb_reg: RB_REG

smallimm: NUM

setflags: SETFLAGS		{ $$ = new Value(1); }
|						{ $$ = new Value(0); }

instcond: NEVER | AL | ZS | ZC | NS | NC | CS | CC

brcond: ALLZS | ALLZC | ANYZS | ANYZC | ALLNS | ALLNC | ANYNS | ANYNC | ALLCS | ALLCC | ANYCS | ANYCC
|						{ $$ = new BrCondition(kAlwaysBr); }

optinstcond: instcond
|						{ $$ = new InstructionCondition(kAlways); }

optabsolute: ABSOLUTE	{ $$ = new Value(1); }
|						{ $$ = new Value(0); }

%%
//-- FUNCTION DEFINITIONS ---------------------------------
